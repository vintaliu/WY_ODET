C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE FUNCTION
OBJECT MODULE PLACED IN ..\OBJ\function.obj
COMPILER INVOKED BY: D:\Program Files (x86)\KeilC51-V952\C51\BIN\C51.EXE ..\Code\function.c OMF2 BROWSE INCDIR(..\Includ
                    -e) DEBUG PRINT(..\Listings\function.lst) TABS(2) OBJECT(..\OBJ\function.obj)

line level    source

   1          #include "SystemInit.h"
   2          #include "function.h"
   3          #include "intrins.h"
   4          #include "stdio.h"
   5          #include "Uart.h"
   6          #include "User_Def.h"
   7          
   8          __O Flag SFR_interrupt_buff_H;
   9          __O Flag SFR_interrupt_buff_L;   //WH
  10          
  11          #define InDeBugMode
  12          unsigned int uiConvertTimes = 0;
  13          unsigned int uiMaxAd = 0;
  14          unsigned int uiMinAd = 0xFFFF;
  15          unsigned long l_gAdTemp = 0;              //unsigned long 32Î»
  16          unsigned int  uiAdVoltage = 0;
  17          
  18          unsigned char ucSpeedGrad;  //ËÙ¶È
  19          unsigned char GLOBAL_SPEED_GRAD = 1;  //È«¾ÖËÙ¶È
  20          
  21          
  22          unsigned char ucLessThanLowPower = FALSE; //µçÔ´µçÑ¹Ð¡ÓÚ23.740µÄ±êÖ¾
  23          unsigned char ucLess18Power = FALSE;      //µçÔ´µçÑ¹Ð¡ÓÚ18µÄ±êÖ¾
  24          unsigned char ucBuzzerPressedFlg = FALSE;    //·äÃùÆ÷°´ÏÂ±êÖ¾
  25          
  26          
  27          unsigned char ucKeyPressFlag = TRUE;
  28          unsigned char ucBuzzerTstFlg = FALSE; //·äÃùÆ÷²âÊÔ±êÖ¾
  29          //unsigned char //ucDebugSpeaker = 0;
  30          //unsigned char PowerOFF = FALSE; //¹Ø»ú±êÖ¾
  31          Peripheral_str strPeripheral;
  32          unsigned short usReadSpeakerPwm(void)
  33          {
  34   1          unsigned short usTemp = 0;
  35   1          SFRSL0 = 1;                          //ÇÐ»»SFR1
  36   1          usTemp = PWM13DH << 8;
  37   1          usTemp |= PWM13DL;
  38   1          SFRSL0 = 0;                          //ÇÐ»»SFR0
  39   1          return (usTemp);
  40   1      }
  41          void delay(unsigned long i)
  42          {
  43   1          while (i--);
  44   1      }
  45          
  46          /*******»ñµÃADµÄÖµ*******/
  47          unsigned int ADC_GetConversionValue(void)
  48          {
  49   1          unsigned int uiTemp = 0;
  50   1          uiTemp = (unsigned int)(ADRH << 8);
  51   1          uiTemp |= ADRL;
  52   1          CLR_ADEOC(); //Æô¶¯×ª»»
  53   1          return uiTemp;
  54   1      }
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 2   

  55          
  56          /*************´¦ÀíAD****************/
  57          void vDealAd(void)
  58          {
  59   1      #define DelaySetAdcRegTime 20
  60   1          unsigned int uiAdValue = 0;
  61   1      
  62   1          if(0 == (ADCCR0 & 0x02))return;
  63   1      
  64   1          uiAdValue = ADC_GetConversionValue();
  65   1          uiConvertTimes++;
  66   1          if(uiAdValue > uiMaxAd)uiMaxAd = uiAdValue;
  67   1          if(uiAdValue < uiMinAd)uiMinAd = uiAdValue;
  68   1          l_gAdTemp += uiAdValue;
  69   1          if(ConverTimes == uiConvertTimes)
  70   1          {
  71   2              uiAdVoltage = (l_gAdTemp - uiMaxAd - uiMinAd) >> 2; //°Ñ6´Î²ÉÑùÖµ  ¼õÈ¥×î´ó¼õÈ¥×îÐ¡³ýÒÔ4
  72   2              uiMinAd = 0xFFFF;
  73   2              uiMaxAd = 0;
  74   2              l_gAdTemp = 0;
  75   2              uiConvertTimes = 0;
  76   2          }
  77   1      }
  78          #ifdef InDeBugMode
  79          //const unsigned char code uiAutoAddFactData[60] =
  80          //{
  81          //    0xEF, 0x0A, 0x1C, 0x07, 0x07, 0x07, 0x62, 0x32, 0x05, 0x07, 0x05, 0x05,
  82          //    0x05, 0x06, 0x14, 0x00, 0x00, 0x00, 0x00, 0x44, 0x14, 0x2D, 0x14, 0x00,
  83          //    0xE8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
  84          //    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  85          //    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x55,
  86          //};
  87          const unsigned char code uiAutoAddFactData[60] =
  88          {
  89              0xEF, 0x0A, 0x00, 0x07, 0x07, 0x07, 0x62, 0x32, 0x05, 0x07, 0x05, 0x05,
  90              0x05, 0x06, 0x14, 0x00, 0x00, 0x00, 0x00, 0x44, 0x14, 0x2D, 0x14, 0x00,
  91              0xE8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
  92              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  93              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x55,
  94          };
  95          #endif
  96          unsigned char ucDebugSwitch = 0;
  97          void vCheckFactData(void)
  98          {
  99   1          unsigned char uiCont = 0;
 100   1          unsigned char ucTemp = 0;
 101   1          unsigned char ucTempData = 0;
 102   1          uiCont = 0;
 103   1          for(ucTemp = 0; ucTemp < EEPROM_START_ADDRESS_FACT_PARE_Legth; ucTemp++)
 104   1          {
 105   2              ucTempData = ucEepromBuf[ucTemp] = EEPROM_Byte_Read(EEPROM_START_ADDRESS_FACT_PARE + ucTemp);
 106   2              if(0xFF == ucTempData)uiCont++;
 107   2      
 108   2          }
 109   1          //    uiCont = 51;//0x19B0
 110   1          if(uiCont > 50)
 111   1          {
 112   2              for(ucTemp = 0; ucTemp < 60; ucTemp++)ucEepromBuf[ucTemp] = 0;
 113   2      #ifdef InDeBugMode
 114   2              for(ucTemp = 0; ucTemp < 60; ucTemp++)ucEepromBuf[ucTemp] = uiAutoAddFactData[ucTemp];
 115   2      #endif
 116   2              //vWrite60Bytes();
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 3   

 117   2              strPeripheral.ucRecvWrite60Bytes_Flag = 1;
 118   2          }
 119   1      
 120   1      }
 121          
 122          void Peripheral_Init(Peripheral_str *p)
 123          {
 124   1      
 125   1          p->Input.all = 0;
 126   1          p->Output.all = 0;
 127   1      
 128   1          p->SpeedDownKeyTime = 0;
 129   1          p->SpeedUpKeyTime = 0;
 130   1          p->SpeakerKeyTime = 0;
 131   1          p->AlarmTime = 0;
 132   1      
 133   1          p->BackSpeekTime = 0;
 134   1          p->PowerLEDShowTime = 0;
 135   1      
 136   1          p->ucPowerLedNum = 0;
 137   1          p->ucPowerLedShowPhase = 0;
 138   1      
 139   1          p->usRecvPowerON_Flag = 0;
 140   1          p->usRecvPowerOFF_Flag = 0;
 141   1      
 142   1          p->ucRecvData_Flag = 0;
 143   1          p->ucRecvPowerValue_Flag = 0;
 144   1          p->ucRecvWrite60Bytes_Flag = 0;
 145   1      
 146   1          p->ucRecvAlarmNum = 0;
 147   1          p->uiRecvPowerValue = 0;  //µçÁ¿
 148   1          p->ucRecvBikeInBack = FALSE;
 149   1          p->ucRecvOrderInCharge  = NO_USE; //ÊÇ·ñÔÚ³äµç
 150   1      
 151   1          p->ucRecvTestFlag  = FALSE;
 152   1      
 153   1      }
 154          /*****µÚÒ»´Î¿ª»ú£¬¿ª»ú»½ÐÑ*********/
 155          unsigned char ucBatType = 0;
 156          void vFirstStart(void)
 157          {
 158   1          vSysSourceInit();//ÏµÍ³³õÊ¼»¯
 159   1          delay(10);
 160   1          clr_EA;
 161   1          GLOBAL_SPEED_GRAD = EEPROM_Byte_Read(SPEED_ADDRESS);;//¶ÁÈ¡FLASE ÖÐµÄÊý¾ÝÄÚÈÝ
 162   1          ucSpeedGrad = GLOBAL_SPEED_GRAD;
 163   1          EEPROM_Read(EEPROM_START_ADDRESS_FACT_PARE, ucEepromBuf, EEPROM_START_ADDRESS_FACT_PARE_Legth);
 164   1          set_EA;
 165   1          ucBatType = EEPROM_Byte_Read(WriteBatteryTypeFlag_Addr);;//¶ÁÈ¡FLASE ÖÐµÄÊý¾ÝÄÚÈÝ
 166   1          if(0 == ucSpeedGrad)
 167   1          {
 168   2              ucSpeedGrad = 1;
 169   2          }
 170   1          else if((ucSpeedGrad >= 5) && (ucSpeedGrad < 100))
 171   1          {
 172   2              ucSpeedGrad = 5;
 173   2          }
 174   1          else if(ucSpeedGrad >= 100)//Èç¹û¿ª»úµÄÊ±ºòÊÇ0xFF
 175   1          {
 176   2              ucSpeedGrad = 1;
 177   2          }
 178   1      
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 4   

 179   1          if((PowerOnSpeedGradeAt > 0) && (PowerOnSpeedGradeAt < 6))ucSpeedGrad = PowerOnSpeedGradeAt;
 180   1      
 181   1          ucLessThanLowPower = FALSE;
 182   1          ucLess18Power = FALSE;
 183   1          strPeripheral.ucRecvOrderInCharge = NO_USE;
 184   1          strPeripheral.ucRecvBikeInBack = FALSE;
 185   1          strPeripheral.uiRecvPowerValue = 0;
 186   1          Peripheral_Init(&strPeripheral);//²ÎÊý³õÊ¼»¯
 187   1          vCheckFactData();//¼ì²âÊý¾ÝÖ¡ÄÚÈÝ£¬Èç¹ûÃ»ÓÐÊý¾Ý×ÔÐÐÉÕÐ´Ò»´Î
 188   1      
 189   1          //////////////////////////////////ÒÔÏÂ½öÎªµ÷ÊÔÄ£Ê½ÏÂÓÐÐ§¹û
 190   1      #ifdef InDeBugMode
 191   1          strPeripheral.ucRecvData_Flag = 0x03;
 192   1          strPeripheral.uiRecvPowerValue = 40000;//µçÁ¿²»ÎªÁãÊ±²Å¼ì²â°´¼ü
 193   1          //
 194   1          SpeedLedOn(ucSpeedGrad);
 195   1          PowerLedOn(strPeripheral.uiRecvPowerValue); //ÏÔÊ¾µçÁ¿
 196   1      #endif
 197   1      
 198   1      }
 199          
 200          /*****ÏÔÊ¾µçÁ¿Ö¸Ê¾µÆ********/
 201          void PowerLedNumOn(unsigned char num)
 202          {
 203   1      
 204   1          switch (num)
 205   1          {
 206   2          case 0:
 207   2              POWER_SHOW_0;
 208   2              break;
 209   2          case 1:
 210   2              POWER_SHOW_1;
 211   2              break;
 212   2          case 2:
 213   2              POWER_SHOW_2;
 214   2              break;
 215   2          case 3:
 216   2              POWER_SHOW_3;
 217   2              break;
 218   2          case 4:
 219   2              POWER_SHOW_4;
 220   2              break;
 221   2          case 5:
 222   2              POWER_SHOW_5;
 223   2              break;
 224   2          default:
 225   2              break;
 226   2          }
 227   1      }
 228          
 229          /*******ÏÔÊ¾ËÙ¶ÈÖ¸Ê¾µÆ*************/
 230          void SpeedLedOn(unsigned char num)
 231          {
 232   1          switch (num)
 233   1          {
 234   2          case 1:
 235   2              SPEED_LED_1;
 236   2              break;
 237   2          case 2:
 238   2              SPEED_LED_2;
 239   2              break;
 240   2          case 3:
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 5   

 241   2              SPEED_LED_3;
 242   2              break;
 243   2          case 4:
 244   2              SPEED_LED_4;
 245   2              break;
 246   2          case 5:
 247   2              SPEED_LED_5;
 248   2              break;
 249   2          default:
 250   2              break;
 251   2          }
 252   1      }
 253          
 254          void PowerLedOn(unsigned short power)    //unsigned shortÎª16Î»
 255          {
 256   1          if(power < 100)return;
 257   1          if (power < ALARM_POWER) ucLess18Power = TRUE;
 258   1          else ucLess18Power = FALSE;
 259   1      
 260   1          if (power <= LOW_POWER)
 261   1          {
 262   2              if(ucLessThanLowPower == FALSE)
 263   2              {
 264   3                  ucLessThanLowPower = TRUE;
 265   3                  POWER_SHOW_0;
 266   3              }
 267   2          }
 268   1          else if (power <= ONE_LED_POWER)
 269   1          {
 270   2              POWER_SHOW_1;
 271   2              ucLessThanLowPower = FALSE;
 272   2          }
 273   1          else if (power <= TWO_LED_POWER)
 274   1          {
 275   2              POWER_SHOW_2;
 276   2              ucLessThanLowPower = FALSE;
 277   2          }
 278   1          else if (power <= THREE_LED_POWER)
 279   1          {
 280   2              POWER_SHOW_3;
 281   2              ucLessThanLowPower = FALSE;
 282   2          }
 283   1          else if (power <= FOUR_LED_POWER)
 284   1          {
 285   2              POWER_SHOW_4;
 286   2              ucLessThanLowPower = FALSE;
 287   2          }
 288   1          else
 289   1          {
 290   2              POWER_SHOW_5;
 291   2              ucLessThanLowPower = FALSE;
 292   2          }
 293   1          if(TRUE == ucLessThanLowPower)//Ç·Ñ¹
 294   1          {
 295   2              if(strPeripheral.PowerLEDShowTime > TIMER_200MS)
 296   2              {
 297   3                  strPeripheral.PowerLEDShowTime = 0;
 298   3                  XorRedPowerLed;
 299   3                  if(ucLess18Power)//µçÑ¹µÍÓÚ18V
 300   3                  {
 301   4                      if ((!strPeripheral.ucRecvBikeInBack) && (!ucBuzzerTstFlg) && (!ucBuzzerPressedFlg) && (!s
             -trPeripheral.ucRecvAlarmNum))
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 6   

 302   4                      {
 303   5                          switch(strPeripheral.ucPowerLedShowPhase)
 304   5                          {
 305   6                          case 0:
 306   6                              SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);
 307   6                              strPeripheral.ucPowerLedShowPhase = 1;
 308   6                              break;
 309   6                          case 1:
 310   6                              SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 1;
 311   6                              strPeripheral.ucPowerLedShowPhase = 0;
 312   6                              break;
 313   6                          default:
 314   6                              SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 2;
 315   6                              strPeripheral.ucPowerLedShowPhase = 0;
 316   6                              break;
 317   6                          }
 318   5                      }
 319   4                  }
 320   3                  else
 321   3                  {
 322   4                      SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 3;
 323   4                      strPeripheral.ucPowerLedShowPhase = 0;
 324   4                  }
 325   3              }
 326   2      
 327   2          }
 328   1          else strPeripheral.PowerLEDShowTime = 0;
 329   1      }
 330          
 331          
 332          
 333          
 334          /*******°´µçÔ´¼ü¹Ø»ú****/
 335          void vPowerPressed(void)
 336          {
 337   1      
 338   1          if(TRUE == strPeripheral.usRecvPowerOFF_Flag)//½«ËÙ¶ÈÖµÐ´ÈëEEPROM
 339   1          {
 340   2              if(GLOBAL_SPEED_GRAD != ucSpeedGrad)
 341   2              {
 342   3                  EEPROM_WriteByte(SPEED_ADDRESS, ucSpeedGrad);
 343   3                  ucSpeedGrad = GLOBAL_SPEED_GRAD;
 344   3              }
 345   2              //      SPEED_LED_0;   //¹Ø±ÕËÙ¶ÈµÆ
 346   2              //      POWER_SHOW_0;  //¹Ø±ÕµçÔ´µÆ
 347   2              strPeripheral.usRecvPowerOFF_Flag = TRUE;
 348   2              strPeripheral.ucRecvData_Flag = FALSE;
 349   2          }
 350   1          //Èç¹ûÓÐµçÔ´¿ª»ú°´¼üµÄÊ±ºò¾ÍÈ¥ ´æ´¢°´¼üÖµ 20181224
 351   1          if(POWER_ON_KEY_PRESSED)
 352   1          {
 353   2              clr_EA;
 354   2              if(GLOBAL_SPEED_GRAD != ucSpeedGrad)
 355   2              {
 356   3                  EEPROM_WriteByte(SPEED_ADDRESS, ucSpeedGrad);
 357   3                  ucSpeedGrad = GLOBAL_SPEED_GRAD;
 358   3              }
 359   2              set_EA;
 360   2          }
 361   1      }
 362          
 363          
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 7   

 364          /**************EEPROMÐ´ÈëÊý¾Ý***********/
 365          void EEPROM_WriteByte(unsigned int u16_addr, unsigned char u8_data)
 366          {
 367   1          EEPROM_Byte_Erase(u16_addr);
 368   1          EEPROM_Byte_Write(u16_addr, u8_data);
 369   1      }
 370          
 371          void vArom_WriteBytes_Fact(unsigned char *pData)//Ö±½ÓÐ´ÈëÒ»¸öÊý¾Ý ²»ÓÃÔÙ½»»»Êý¾ÝÁË
 372          {
 373   1      
 374   1          unsigned char i = 0;
 375   1          clr_EA;
 376   1          for(i = 0; i < EEPROM_START_ADDRESS_FACT_PARE_Legth; i++)
 377   1          {
 378   2              EEPROM_WriteByte(EEPROM_START_ADDRESS_FACT_PARE + i, pData[i]);
 379   2          }
 380   1          set_EA;
 381   1          set_ES;//ÔÙ´Î¿ªÆô ´®¿ÚÖÐ¶Ï
 382   1      }
 383          
 384          //void vArom_WriteBytes_Fact(unsigned char *pData)//Ö±½ÓÐ´ÈëÒ»¸öÊý¾Ý ²»ÓÃÔÙ½»»»Êý¾ÝÁË
 385          //{
 386          //    uint8_t cnt;
 387          //    uint16_t addr_60Byte = EEPROM_START_ADDRESS_FACT_PARE;
 388          //    clr_EA;
 389          //
 390          //    SET_IAPEN();
 391          //    SET_IAPEN(); //´ò¿ªFALSH IAP¹¦ÄÜ£¬Á¬ÐøÐ´Á½±éÓÐÐ§
 392          //    SET_EPAGEERS();
 393          //    SET_EPAGEERS(); //Ò³²ÁÄ£Ê½
 394          //    IAPKEY = 0x5a;
 395          //    IAPKEY = 0xa5;
 396          //    SET_IAPSTR(); //IAPSTRÎ»ÖÃÒ»£¬Æô¶¯IAP²Ù×÷
 397          //    for (cnt = 0; cnt < 61; cnt++)
 398          //    {
 399          //        IAPADH = addr_60Byte >> 8;
 400          //        IAPADL = addr_60Byte;
 401          //        IAPDB = 0;
 402          //        addr_60Byte++;
 403          //    }
 404          //    IAPKEY = 0x5a;
 405          //    IAPKEY = 0xa5;
 406          //    SET_IAPTRIG0(); //IAPTRIG0ÖÃÒ»
 407          //    IAPKEY = 0x5a;
 408          //    IAPKEY = 0xa5;
 409          //    SET_IAPTRIG1(); //IAPTRIG1ÖÃÒ»
 410          //    IAPKEY = 0x5a;
 411          //    IAPKEY = 0xa5;
 412          //    SET_IAPTRIG2(); //IAPTRIG1ÖÃÒ»
 413          //    while (IAPCR & 0x80);
 414          
 415          //    addr_60Byte = EEPROM_START_ADDRESS_FACT_PARE;
 416          
 417          //    SET_IAPEN();
 418          //    SET_IAPEN(); //´ò¿ªFALSH IAP¹¦ÄÜ£¬Á¬ÐøÐ´Á½±éÓÐÐ§
 419          //    SET_EPAGEWR();
 420          //    SET_EPAGEWR(); //Ò³Ð´Ä£Ê½
 421          //    IAPKEY = 0x5a;
 422          //    IAPKEY = 0xa5;
 423          //    SET_IAPSTR(); //IAPSTRÎ»ÖÃÒ»,Æô¶¯IAP²Ù×÷
 424          //    for (cnt = 0; cnt < 61; cnt++)
 425          //    {
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 8   

 426          //        IAPADH = addr_60Byte >> 8;
 427          //        IAPADL = addr_60Byte;
 428          //        IAPDB = pData[cnt];
 429          //        addr_60Byte++;
 430          //    }
 431          //    IAPKEY = 0x5a;
 432          //    IAPKEY = 0xa5;
 433          //    SET_IAPTRIG0(); //IAPTRIG0ÖÃÒ»
 434          //    IAPKEY = 0x5a;
 435          //    IAPKEY = 0xa5;
 436          //    SET_IAPTRIG1(); //IAPTRIG1ÖÃÒ»
 437          //    IAPKEY = 0x5a;
 438          //    IAPKEY = 0xa5;
 439          //    SET_IAPTRIG2(); //IAPTRIG1ÖÃÒ»
 440          //    while (IAPCR & 0x80); //IAPSTR
 441          
 442          //    set_EA;
 443          //}
 444          /**********Ö÷¿ØÐ´Èë60×Ö½ÚÊý¾Ý**************/
 445          void vWrite60Bytes(void)
 446          {
 447   1          clr_EA;
 448   1          vArom_WriteBytes_Fact(&ucEepromBuf[0]);
 449   1          set_EA;
 450   1      }
 451          
 452          void vTestShowLed(unsigned int value)
 453          {
 454   1          //    if (value & 0x0001) POWER_SHOW1_ON;
 455   1          //    else POWER_SHOW1_OFF;
 456   1      
 457   1          //    if (value & 0x0002) POWER_SHOW2_ON;
 458   1          //    else POWER_SHOW2_OFF;
 459   1      
 460   1          //    if (value & 0x0004) POWER_SHOW3_ON;
 461   1          //    else POWER_SHOW3_OFF;
 462   1      
 463   1          //    if (value & 0x0008) POWER_SHOW4_ON;
 464   1          //
 465   1          //    else POWER_SHOW4_OFF;
 466   1      
 467   1          //    if (value & 0x0010) POWER_SHOW5_ON;
 468   1          //    else POWER_SHOW5_OFF;
 469   1      
 470   1          if (value & 0x0020) SPEED_STEP1_ON;
 471   1          else SPEED_STEP1_OFF;
 472   1      
 473   1          if (value & 0x0040) SPEED_STEP2_ON;
 474   1          else SPEED_STEP2_OFF;
 475   1      
 476   1          if (value & 0x0080) SPEED_STEP3_ON;//·½±ã²»¿ª»úµÄÊ±ºò  ¿ìËÙÇø·Ö°´¼ü°æ±¾µÄ²»Í¬
 477   1          else SPEED_STEP3_OFF;
 478   1      
 479   1          if (value & 0x0100) SPEED_STEP4_ON;
 480   1          else SPEED_STEP4_OFF;
 481   1      
 482   1          if (value & 0x0200)
 483   1          {
 484   2              SPEED_STEP5_ON;
 485   2          }
 486   1          else
 487   1          {
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 9   

 488   2              SPEED_STEP5_OFF;
 489   2          }
 490   1      }
 491          
 492          void vInitLedPin(void)
 493          {
 494   1          POWER_SHOW_0;
 495   1          SPEED_LED_0;
 496   1          GPIO_Init();
 497   1      }
 498          
 499          void SetPWM1_Out(unsigned int x, unsigned int y)
 500          {
 501   1          SFRSL0 = 1;                          //ÇÐ»»SFR1
 502   1      
 503   1          PWM1PH = (unsigned char)(x >> 8);
 504   1          PWM1PL = (unsigned char)(x);
 505   1          PWM13DH =  (unsigned char)(y >> 8);
 506   1          PWM13DL =  (unsigned char)(y);
 507   1      
 508   1          SFRSL0 = 0;                         //ÇÐ»»SFR0
 509   1      }
 510          
 511          
 512          void Peripheral_GPIOInput(unsigned int  Voltage)
 513          {
 514   1          if(Globle_Timer_1MS.Bits.CheckKeyPress)
 515   1          {
 516   2              Globle_Timer_1MS.Bits.CheckKeyPress = 0;
 517   2              if(Voltage > 3350)//4096
 518   2              {
 519   3                  ucKeyPressFlag = FALSE;
 520   3                  strPeripheral.SpeedUpKeyTime = 0;
 521   3                  strPeripheral.SpeedDownKeyTime = 0;
 522   3                  strPeripheral.SpeakerKeyTime = 0;
 523   3                  strPeripheral.SpeedDownAndUpTime = 0;
 524   3                  strPeripheral.SpeakerAndSpeedUpTime = 0;
 525   3                  strPeripheral.Input.Bits.SpeedDownKeyPressFlag =  0;
 526   3      #ifdef EnableCancelBackCarAlarm
 527   3                  strPeripheral.Input.all &= 0xB0;
 528   3      #else         
                          strPeripheral.Input.all &= 0x30;
              #endif          
 531   3              }
 532   2              else if((FALSE == ucKeyPressFlag) && (Voltage < 3300) && (Voltage > 2819))//else if((FALSE == ucKe
             -yPressFlag) && (Voltage < 3300) && (Voltage > 2800))//+  //3300  2800  -->ADC as 2908  MC51F003  2940
 533   2              {
 534   3                  strPeripheral.SpeedUpKeyTime++;
 535   3                  strPeripheral.SpeedDownKeyTime = 0;
 536   3                  strPeripheral.SpeedDownAndUpTime = 0;
 537   3                  strPeripheral.Input.Bits.SpeedDownKeyPressFlag =  0;
 538   3                  if(strPeripheral.SpeedUpKeyTime > TIMER_20MS)
 539   3                  {
 540   4                      strPeripheral.SpeedUpKeyTime = TIMER_20MS;
 541   4                      strPeripheral.Input.Bits.SpeedUpKey = TRUE;
 542   4                      ucKeyPressFlag = TRUE;
 543   4                  }
 544   3              }
 545   2              else if((FALSE == ucKeyPressFlag) && (Voltage < 2715) && (Voltage > 2514))//else if((FALSE == ucKe
             -yPressFlag) && (Voltage < 2680) && (Voltage > 2450))//-  // 2750 2450   -->ADC as 2569    MC51F003 2590
 546   2              {
 547   3                  strPeripheral.SpeedUpKeyTime = 0;
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 10  

 548   3                  strPeripheral.SpeedDownAndUpTime = 0;
 549   3                  strPeripheral.SpeedDownKeyTime++;
 550   3                  if(strPeripheral.SpeedDownKeyTime > TIMER_20MS)
 551   3                  {
 552   4                      strPeripheral.SpeedDownKeyTime = TIMER_20MS;
 553   4                      strPeripheral.Input.Bits.SpeedDownKey = TRUE;
 554   4                      strPeripheral.Input.Bits.SpeedDownKeyPressFlag = TRUE;
 555   4                      ucKeyPressFlag = TRUE;
 556   4                  }
 557   3              }
 558   2              else if((TRUE == strPeripheral.Input.Bits.SpeedDownKeyPressFlag) && (Voltage < 2435) && (Voltage >
             - 2265))//else if((TRUE == strPeripheral.Input.Bits.SpeedDownKeyPressFlag) && (Voltage < 2437) && (Voltage > 2237)) //+ -
             -  Í¬Ê±°´ÏÂ2450 2200  -->ADC as 2337    MC51F003  2355
 559   2              {
 560   3                  strPeripheral.SpeedDownAndUpTime++;  //±ØÐë°´¼ü¼õÏÈ°´ÏÂÈ¥
 561   3                  if(strPeripheral.SpeedDownAndUpTime > TIMER_4000MS)
 562   3                  {
 563   4                      strPeripheral.SpeedDownAndUpTime = TIMER_4000MS;
 564   4                      if(strPeripheral.Input.Bits.PowerChange == FALSE)//20190923ÐÞ¸ÄÇÐ»»µç³ØÀàÐÍ²»½øÐÐÐÞ¸Ä×î¸ßÊ
             -±ËÙÊ±
 565   4                          strPeripheral.Input.Bits.SpeedChange = TRUE;
 566   4                      ucKeyPressFlag = TRUE;
 567   4                      POWER_SHOW_5;
 568   4                      SPEED_LED_5;
 569   4                      SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);  //Êä³ö¿ØÖÆ·äÃùÆ÷½Ð
 570   4                  }
 571   3              }
 572   2              else if((Voltage < 2164) && (Voltage > 1944))//else if((Voltage < 2200) && (Voltage > 1900)) //205
             -4 À®°È2200 1900    -->ADC as 2049    MC51F003  2074
 573   2              {
 574   3                  strPeripheral.SpeakerKeyTime++;
 575   3                  strPeripheral.SpeedDownAndUpTime = 0;
 576   3                  strPeripheral.SpeakerAndSpeedUpTime = 0;
 577   3                  strPeripheral.Input.Bits.SpeedDownKeyPressFlag =  0;
 578   3                  if(strPeripheral.SpeakerKeyTime > TIMER_20MS)
 579   3                  {
 580   4                      strPeripheral.SpeakerKeyTime = TIMER_20MS;
 581   4                      strPeripheral.Input.Bits.SpeakerKey = TRUE;
 582   4                      //ucKeyPressFlag = TRUE;
 583   4                  }
 584   3              }
 585   2              else if((TRUE == strPeripheral.Input.Bits.SpeakerKey) && (Voltage < 1852) && (Voltage > 1680)) //e
             -lse if((TRUE == strPeripheral.Input.Bits.SpeakerKey) && (Voltage < 1900) && (Voltage > 1650)) //1706À®°È +  Í¬Ê±°´ÏÂ1900
             -  1650  -->ADC as1702    MC51F003  1722
 586   2              {
 587   3                  //±ØÐë°´¼ü¼ÓÏÈ°´ÏÂÈ¥
 588   3                  strPeripheral.SpeakerAndSpeedUpTime++;
 589   3                  if(strPeripheral.SpeakerAndSpeedUpTime > 1000)
 590   3                  {
 591   4                      strPeripheral.SpeakerAndSpeedUpTime = 1000;
 592   4                      strPeripheral.Input.Bits.SpeakerKey = FALSE;
 593   4                      ucKeyPressFlag = TRUE;
 594   4      
 595   4                      if((TRUE != strPeripheral.ucRecvOrderInCharge) && (0 == strPeripheral.ucRecvAlarmNum) && \
 596   4                              (strPeripheral.Input.Bits.SpeedModify == FALSE))//20190923ÐÞ¸ÄÇÐ»»×î¸ßÊ±ËÙÊ±²»½øÐÐ
             -ÐÞ¸Äµç³ØÀàÐÍ
 597   4                      {
 598   5                          if(strPeripheral.Input.Bits.PowerChange == FALSE)//20190807 ÐÞ¸Äµç³ØÀàÐÍ ÖØÐÂÉÏµçºóÓÐÐ
             -§
 599   5                          {
 600   6      
 601   6                              if((ucEepromBuf[2] & 0x40) == 0x40)//ï®µç³Ø
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 11  

 602   6                              {
 603   7                                  ucEepromBuf[2] &= 0xBF;//Ç¦Ëá
 604   7                              }
 605   6                              else
 606   6                              {
 607   7                                  ucEepromBuf[2] |= 0x40; //ï®µç³Ø
 608   7                              }
 609   6                              vWrite60Bytes();
 610   6                              strPeripheral.Input.Bits.PowerChange = TRUE;
 611   6                              vSendLedStatus(strPeripheral.Input.all, ucEepromBuf[2]);
 612   6                          }
 613   5                          SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);
 614   5                          SpeedLedOn(ucSpeedGrad);
 615   5                          strPeripheral.Output.Bits.Alarm = TRUE;
 616   5                      }
 617   4                  }
 618   3              }
 619   2      #ifdef EnableCancelBackCarAlarm
 620   2              else if((TRUE == strPeripheral.Input.Bits.SpeakerKey) && (Voltage < 1650) && (Voltage > 1400)) //e
             -lse if((TRUE == strPeripheral.Input.Bits.SpeakerKey) && (Voltage < 1900) && (Voltage > 1650)) //1706À®°È +  Í¬Ê±°´ÏÂ1900
             -  1650  -->ADC as1702    MC51F003  1722
 621   2              {
 622   3                  //±ØÐë°´¼ü¼ÓÏÈ°´ÏÂÈ¥
 623   3                  strPeripheral.SpeedDownKeyTime++;
 624   3                  if(strPeripheral.SpeedDownKeyTime > 1000)
 625   3                  {
 626   4                      strPeripheral.SpeedDownKeyTime = 1000;
 627   4                      strPeripheral.Input.Bits.SpeakerKey = FALSE;
 628   4                      ucKeyPressFlag = TRUE;
 629   4      
 630   4                      if((TRUE != strPeripheral.ucRecvOrderInCharge) && (0 == strPeripheral.ucRecvAlarmNum) && \
 631   4                              (strPeripheral.Input.Bits.BackCarAlarmModify == FALSE))//20190923ÐÞ¸ÄÇÐ»»×î¸ßÊ±ËÙÊ
             -±²»½øÐÐÐÞ¸Äµç³ØÀàÐÍ
 632   4                      {
 633   5                          if(strPeripheral.Input.Bits.PowerChange == FALSE)//20190807 ÐÞ¸Äµç³ØÀàÐÍ ÖØÐÂÉÏµçºóÓÐÐ
             -§
 634   5                          {
 635   6                              if(ucEepromBuf[0])ucEepromBuf[0] = 0;//Èç¹ûÄÚÖÃÀ®°ÈÓÐÉùÏìÁË£¬¾Í²»ÒªÔÙÏìÁË
 636   6                              else ucEepromBuf[0] = 1;  //Èç¹ûÄÚÖÃÀ®°ÈÎÞÉùÏìÁË£¬ÔÙ´Î¿ªÆô
 637   6                              strPeripheral.Input.Bits.PowerChange = TRUE;
 638   6                              strPeripheral.Input.Bits.BackCarAlarmModify = TRUE;
 639   6                              vWrite60Bytes();
 640   6                          }
 641   5                          SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);
 642   5                          SpeedLedOn(ucSpeedGrad);
 643   5                          strPeripheral.Output.Bits.Alarm = TRUE;
 644   5                      }
 645   4                  }
 646   3              }
 647   2      #endif        
 648   2              //        else if((FALSE == ucKeyPressFlag) && (Voltage < 1650) && (Voltage > 1400)) //1584 À®°È -
             -  Í¬Ê±°´ÏÂ
 649   2              //        {//È¡ÏûÔ­À®°ÈÓëËÙ¶È¼õÒ»Æðµ÷½ÚËÙ¶È¹¦ÄÜ
 650   2              //            strPeripheral.SpeedDownKeyTime++;
 651   2              //            if(strPeripheral.SpeedDownKeyTime > TIMER_100MS)
 652   2              //            {
 653   2              //                strPeripheral.SpeedDownKeyTime = TIMER_100MS;
 654   2              //                strPeripheral.Input.Bits.SpeedChange = FALSE;
 655   2              //                strPeripheral.Input.Bits.SpeakerKey = FALSE;
 656   2              //                ucKeyPressFlag = TRUE;
 657   2              //            }
 658   2              //        }
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 12  

 659   2              else if(Voltage <  1400) //Í¬Ê±°´ÏÂ
 660   2              {
 661   3                  if(strPeripheral.Input.Bits.SpeakerKey)
 662   3                  {
 663   4                      strPeripheral.Input.Bits.SpeakerKey = FALSE;
 664   4                  }
 665   3              }
 666   2              /*if(strPeripheral.Input.Bits.SpeakerKey)
 667   2              {
 668   2                  if(Voltage > 300)
 669   2                  {
 670   2                    strPeripheral.Input.Bits.SpeakerKey = FALSE;
 671   2                  }
 672   2              }
 673   2              if(Voltage < 300)
 674   2              {
 675   2                  strPeripheral.SpeakerKeyTime++;
 676   2                  if(strPeripheral.SpeakerKeyTime > TIMER_10MS)
 677   2                  {
 678   2                      strPeripheral.SpeakerKeyTime = TIMER_10MS;
 679   2                      strPeripheral.Input.Bits.SpeakerKey = TRUE;
 680   2                  }
 681   2              }*/
 682   2          }
 683   1      }
 684          
 685          void PeripheralInputHandle(void)
 686          {
 687   1      
 688   1          Peripheral_GPIOInput(uiAdVoltage);
 689   1      
 690   1      
 691   1          if(strPeripheral.Input.Bits.SpeedUpKey)
 692   1          {
 693   2              if ( (TRUE != strPeripheral.ucRecvOrderInCharge) && (0 == strPeripheral.ucRecvAlarmNum))
 694   2              {
 695   3                  strPeripheral.Input.Bits.SpeedUpKey = 0;
 696   3                  ucSpeedGrad++;
 697   3                  if(ucSpeedGrad > 5)
 698   3                  {
 699   4                      ucSpeedGrad = 5;
 700   4                      SetPWM1_Out(SpeedKeyLimitTime, SpeedKeyLimitPulse);
 701   4                      if(strPeripheral.Input.Bits.SpeedModify)//20190807 ÐÞ¸Ä×î¸ßÊ±ËÙ ÖØÐÂÉÏµçºóÓÐÐ§
 702   4                      {
 703   5                          ucEepromBuf[6] = 87;
 704   5                          vWrite60Bytes();
 705   5                      }
 706   4                  }
 707   3                  else
 708   3                  {
 709   4                      SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);
 710   4                      SpeedLedOn(ucSpeedGrad);
 711   4                      if(strPeripheral.Input.Bits.SpeedModify)//20190807 ÐÞ¸Ä×î¸ßÊ±ËÙ ÖØÐÂÉÏµçºóÓÐÐ§
 712   4                      {
 713   5                          if(ucEepromBuf[6] < 87)
 714   5                          {
 715   6                              ucEepromBuf[6] += 10;
 716   6                          }
 717   5                          vWrite60Bytes();
 718   5                          vSendLedStatus(strPeripheral.Input.all, ucEepromBuf[6]);
 719   5                      }
 720   4                      else vSendSpeedGrad(ucSpeedGrad);
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 13  

 721   4                  }
 722   3                  strPeripheral.Output.Bits.Alarm = TRUE;
 723   3      
 724   3              }
 725   2              else strPeripheral.Input.Bits.SpeedUpKey = 0;
 726   2          }
 727   1          if(strPeripheral.Input.Bits.SpeedDownKey)
 728   1          {
 729   2              strPeripheral.Input.Bits.SpeedDownKey = 0;
 730   2      
 731   2              if((TRUE != strPeripheral.ucRecvOrderInCharge) && (0 == strPeripheral.ucRecvAlarmNum))
 732   2              {
 733   3                  ucSpeedGrad--;
 734   3                  if(0 == ucSpeedGrad)
 735   3                  {
 736   4                      ucSpeedGrad = 1;
 737   4                      SetPWM1_Out(SpeedKeyLimitTime, SpeedKeyLimitPulse);
 738   4                      if(strPeripheral.Input.Bits.SpeedModify)//20190807 ÐÞ¸Ä×î¸ßÊ±ËÙ ÖØÐÂÉÏµçºóÓÐÐ§
 739   4                      {
 740   5                          ucEepromBuf[6] = 47;
 741   5                          vWrite60Bytes();
 742   5                      }
 743   4                  }
 744   3                  else
 745   3                  {
 746   4                      SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);
 747   4                      SpeedLedOn(ucSpeedGrad);
 748   4      
 749   4                      if(strPeripheral.Input.Bits.SpeedModify)//20190807 ÐÞ¸Ä×î¸ßÊ±ËÙ ÖØÐÂÉÏµçºóÓÐÐ§
 750   4                      {
 751   5                          if(ucEepromBuf[6] > 47)
 752   5                          {
 753   6                              ucEepromBuf[6] -= 10;
 754   6                          }
 755   5                          vWrite60Bytes();
 756   5                          vSendLedStatus(strPeripheral.Input.all, ucEepromBuf[6]);
 757   5                      }
 758   4                      else vSendSpeedGrad(ucSpeedGrad);
 759   4                  }
 760   3                  strPeripheral.Output.Bits.Alarm = TRUE;
 761   3      
 762   3              }
 763   2              else strPeripheral.Input.Bits.SpeedDownKey = 0;
 764   2          }
 765   1          if(strPeripheral.Input.Bits.SpeedChange)//ÐÞ¸Ä×î¸ßÊ±ËÙ
 766   1          {
 767   2              if(0 == strPeripheral.ucRecvAlarmNum)
 768   2              {
 769   3      
 770   3                  if(ucEepromBuf[6] >= 87)
 771   3                  {
 772   4                      ucSpeedGrad = 5;
 773   4                      ucEepromBuf[6] = 87;
 774   4                  }
 775   3                  else if(ucEepromBuf[6] <= 47)
 776   3                  {
 777   4                      ucSpeedGrad = 1;
 778   4                      ucEepromBuf[6] = 47;
 779   4                  }
 780   3                  else if(ucEepromBuf[6] <= 57)
 781   3                  {
 782   4                      ucSpeedGrad = 2;
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 14  

 783   4                      ucEepromBuf[6] = 57;
 784   4                  }
 785   3                  else if(ucEepromBuf[6] <= 67)
 786   3                  {
 787   4                      ucSpeedGrad = 3;
 788   4                      ucEepromBuf[6] = 67;
 789   4                  }
 790   3                  else if(ucEepromBuf[6] <= 77)
 791   3                  {
 792   4                      ucSpeedGrad = 4;
 793   4                      ucEepromBuf[6] = 77;
 794   4                  }
 795   3                  SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);
 796   3                  SpeedLedOn(ucSpeedGrad);
 797   3      
 798   3                  strPeripheral.Input.Bits.SpeedChange = 0;
 799   3                  strPeripheral.Input.Bits.SpeedModify = 1;
 800   3                  strPeripheral.ucPowerLedNum = 0;
 801   3                  strPeripheral.Output.Bits.Alarm = TRUE;
 802   3                  vSendLedStatus(strPeripheral.Input.all, ucEepromBuf[6]);
 803   3              }
 804   2              else
 805   2              {
 806   3                  strPeripheral.Input.Bits.SpeedChange = 0;
 807   3                  strPeripheral.Input.Bits.SpeedModify = 0;
 808   3              }
 809   2          }
 810   1          if(strPeripheral.Input.Bits.SpeakerKey)
 811   1          {
 812   2              if (TRUE != strPeripheral.ucRecvOrderInCharge)
 813   2              {
 814   3                  strPeripheral.Output.Bits.Alarm = TRUE;
 815   3                  SetPWM1_Out(LabaKeyPressSpeekTime, LabaKeyPressSpeekPulse);
 816   3                  if(FALSE == ucBuzzerPressedFlg)vSendBuzzerOrder(0x01);
 817   3                  ucBuzzerPressedFlg = TRUE;
 818   3              }
 819   2          }
 820   1          else
 821   1          {
 822   2              if(TRUE == ucBuzzerPressedFlg) vSendBuzzerOrder(0x02);
 823   2              ucBuzzerPressedFlg = FALSE;
 824   2          }
 825   1          //    }
 826   1      }
 827          
 828          //unsigned char strPeripheral.ucPowerLedShowPhase = 0;
 829          char ucBackSpeekFlag = FALSE;
 830          char ucBeep_Alarm_Phase = 0;
 831          char ucBeep_Alarm_Num = 0;
 832          //char ucTestBeep = 0;
 833          void PeripheralOutputHandle(void)
 834          {
 835   1          /*******µçÔ´µÆ*******/
 836   1          if(Globle_Timer_1MS.Bits.PowerOn)
 837   1          {
 838   2              Globle_Timer_1MS.Bits.PowerOn = 0;
 839   2              if(strPeripheral.PowerLEDShowTime <= TIMER_1S)
 840   2              {
 841   3                  strPeripheral.PowerLEDShowTime++;
 842   3              }
 843   2              else strPeripheral.PowerLEDShowTime = 0;
 844   2      
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 15  

 845   2              //////////////////////////////////////
 846   2          }
 847   1          /*******¼ì²âÊÇ·ñÐ´EEPROM*******/
 848   1          if(strPeripheral.ucRecvWrite60Bytes_Flag)
 849   1          {
 850   2              if(strPeripheral.PowerLEDShowTime > TIMER_200MS)
 851   2              {
 852   3                  strPeripheral.PowerLEDShowTime = 0;
 853   3                  switch(strPeripheral.ucPowerLedShowPhase)
 854   3                  {
 855   4                  case 0:
 856   4                      SPEED_LED_0;
 857   4                      POWER_SHOW_0;
 858   4                      SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 4;
 859   4                      strPeripheral.ucPowerLedShowPhase = 1;
 860   4                      vWrite60Bytes();
 861   4                      strPeripheral.ucPowerLedNum = 5;
 862   4                      break;
 863   4                  case 1:
 864   4                      if(strPeripheral.ucPowerLedNum > 0)
 865   4                      {
 866   5                          PowerLedNumOn(strPeripheral.ucPowerLedNum--);
 867   5                          SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);
 868   5                      }
 869   4                      else strPeripheral.ucPowerLedShowPhase = 2;
 870   4                      break;
 871   4                  case 2:
 872   4                      SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 5;
 873   4                      POWER_SHOW_0;  //¹Ø±ÕµçÔ´µÆ
 874   4                      SpeedLedOn(ucSpeedGrad);  //ÏÔÊ¾ËÙ¶È
 875   4                      strPeripheral.ucPowerLedShowPhase = 0;
 876   4                      strPeripheral.ucRecvWrite60Bytes_Flag = 0;
 877   4                      break;
 878   4                  default:
 879   4                      SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 6;
 880   4                      strPeripheral.ucPowerLedShowPhase = 0;
 881   4                      strPeripheral.ucRecvWrite60Bytes_Flag = 0;
 882   4                      break;
 883   4                  }
 884   3              }
 885   2          }
 886   1          else if(0x03 == strPeripheral.ucRecvData_Flag)    //´®¿ÚÍ¨ÐÅ¸³Öµ0X03
 887   1          {
 888   2              if(TRUE == strPeripheral.usRecvPowerON_Flag)   //  Ôö¼ÓÒ»¸ö¿ª»úÃüÁî
 889   2              {
 890   3                  if(strPeripheral.PowerLEDShowTime >= TIMER_100MS)
 891   3                  {
 892   4                      strPeripheral.PowerLEDShowTime = 0;
 893   4                      switch(strPeripheral.ucPowerLedShowPhase)
 894   4                      {
 895   5                      case 0:
 896   5                          POWER_SHOW_0;
 897   5                          SPEED_LED_0;
 898   5      
 899   5                          SetPWM1_Out(SpeedKeyTime, 0);  //ucDebugSpeaker = 7;//Êä³ö¿ØÖÆ·äÃùÆ÷½Ð
 900   5                          strPeripheral.ucPowerLedShowPhase = 1;
 901   5                          strPeripheral.ucPowerLedNum = 0;
 902   5                          break;
 903   5                      case 1:
 904   5                          if(0x40 == (ucBatType & 0x40)) //Èç¹ûÊÇï®µçÄ£Ê½
 905   5                          {
 906   6                              if(strPeripheral.ucPowerLedNum < 2)
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 16  

 907   6                              {
 908   7                                  if(strPeripheral.ucPowerLedNum  == 0)
 909   7                                  {
 910   8                                      POWER_SHOW_5;
 911   8                                      SPEED_LED_5;
 912   8                                      SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);  //Êä³ö¿ØÖÆ·äÃùÆ÷½Ð
 913   8                                  }
 914   7                                  else
 915   7                                  {
 916   8                                      POWER_SHOW_0;
 917   8                                      SPEED_LED_0;
 918   8                                      SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 8;
 919   8                                  }
 920   7                                  strPeripheral.ucPowerLedNum++;
 921   7                              }
 922   6                              else
 923   6                              {
 924   7                                  strPeripheral.ucPowerLedNum = 0;
 925   7                                  SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);  //Êä³ö¿ØÖÆ·äÃùÆ÷½Ð
 926   7                                  strPeripheral.ucPowerLedShowPhase = 2;
 927   7                              }
 928   6                          }
 929   5                          else//Ç¦Ëáµç³ØÃù½ÐÒ»´Î
 930   5                          {
 931   6                              POWER_SHOW_5;
 932   6                              SPEED_LED_5;
 933   6                              SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);  //Êä³ö¿ØÖÆ·äÃùÆ÷½Ð
 934   6                              strPeripheral.ucPowerLedShowPhase = 2;
 935   6                          }
 936   5                          //                            if(strPeripheral.ucPowerLedNum < 6)
 937   5                          //                            {
 938   5                          //                                PowerLedNumOn(strPeripheral.ucPowerLedNum);
 939   5                          //                                SpeedLedOn(ucSpeedGrad);
 940   5                          //                                SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse);  //Êä³ö¿ØÖÆ·äÃùÆ÷½Ð
 941   5                          //                                  strPeripheral.ucPowerLedNum ++;
 942   5                          //                            }
 943   5                          //                            else  strPeripheral.ucPowerLedShowPhase = 2;
 944   5                          break;
 945   5                      case 2:
 946   5                          //µçÁ¿µÆ,ËÙ¶ÈµÆÈ«Ãð
 947   5                          POWER_SHOW_0;
 948   5                          SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 9;
 949   5                          strPeripheral.ucPowerLedShowPhase = 3;
 950   5                          break;
 951   5                      case 3:
 952   5                          //µçÁ¿µÆ
 953   5                          POWER_SHOW_5;
 954   5                          //PowerLedOn(strPeripheral.uiRecvPowerValue); //ÏÔÊ¾µçÁ¿
 955   5                          //µãÁÁËÙ¶ÈµÆ
 956   5                          SpeedLedOn(ucSpeedGrad);   //
 957   5                          strPeripheral.ucPowerLedShowPhase = 0;
 958   5                          strPeripheral.usRecvPowerON_Flag = 0x03;      //Ö»Ö´ÐÐÒ»´Î£¨¿ª»úÊ±Ö´ÐÐ£©
 959   5                          strPeripheral.ucPowerLedShowPhase = 0;
 960   5                          ucBeep_Alarm_Phase = 0;
 961   5                          ucBeep_Alarm_Num = 0;
 962   5                          ucLessThanLowPower = 0;
 963   5                          strPeripheral.ucPowerLedNum  = 0;
 964   5                          break;
 965   5                      }
 966   4                  }
 967   3              }
 968   2              /*******¼ì²âÊÇ·ñ³äµçÖÐ*******/
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 17  

 969   2              else if (TRUE == strPeripheral.ucRecvOrderInCharge)
 970   2              {
 971   3                  if(strPeripheral.PowerLEDShowTime > TIMER_300MS)
 972   3                  {
 973   4                      strPeripheral.ucPowerLedNum %= 5;
 974   4                      strPeripheral.ucPowerLedNum++;
 975   4                      SPEED_LED_5;
 976   4                      PowerLedNumOn(strPeripheral.ucPowerLedNum);
 977   4                      strPeripheral.PowerLEDShowTime = 0;
 978   4                  }
 979   3              }
 980   2              else if(strPeripheral.ucRecvAlarmNum)//ÓÐ¹ÊÕÏ
 981   2              {
 982   3                  switch(ucBeep_Alarm_Phase)
 983   3                  {
 984   4                  case 0:
 985   4                      SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 10;
 986   4                      SPEED_LED_0;
 987   4                      POWER_SHOW_0;
 988   4                      ucBeep_Alarm_Phase = 1;
 989   4                      break;
 990   4                  case 1:
 991   4                      if(strPeripheral.PowerLEDShowTime >= TIMER_400MS)
 992   4                      {
 993   5                          SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse); //·äÃùÆ÷ÏìÒ»Éù
 994   5                          POWER_SHOW_5;                      //µçÁ¿µÆÈ«ÁÁ
 995   5                          strPeripheral.PowerLEDShowTime = 0;
 996   5                          ucBeep_Alarm_Phase = 2;
 997   5                      }
 998   4                      break;
 999   4                  case 2:
1000   4                      if(strPeripheral.ucRecvAlarmNum < 0x80)
1001   4                      {
1002   5                          if(strPeripheral.PowerLEDShowTime >= TIMER_400MS)
1003   5                          {
1004   6                              SetPWM1_Out(0, 0); //·äÃùÆ÷ÏìÒ»Éù
1005   6                              POWER_SHOW_0;                      //µçÁ¿µÆÈ«ÁÁ
1006   6                              strPeripheral.PowerLEDShowTime = 0;
1007   6                              ucBeep_Alarm_Num++;
1008   6                              if(ucBeep_Alarm_Num < strPeripheral.ucRecvAlarmNum)
1009   6                                  ucBeep_Alarm_Phase = 1;
1010   6                              else
1011   6                                  ucBeep_Alarm_Phase = 3;
1012   6                          }
1013   5                      }
1014   4                      else
1015   4                      {
1016   5                          if(strPeripheral.PowerLEDShowTime >= TIMER_200MS)
1017   5                          {
1018   6                              SetPWM1_Out(0, 0); //·äÃùÆ÷ÏìÒ»Éù
1019   6                              POWER_SHOW_0;                      //µçÁ¿µÆÈ«ÁÁ
1020   6                              strPeripheral.PowerLEDShowTime = 0;
1021   6                              ucBeep_Alarm_Num++;
1022   6                              if(ucBeep_Alarm_Num < (strPeripheral.ucRecvAlarmNum - 0x80))
1023   6                                  ucBeep_Alarm_Phase = 1;
1024   6                              else
1025   6                                  ucBeep_Alarm_Phase = 3;
1026   6                          }
1027   5                      }
1028   4                      break;
1029   4                  case 3:
1030   4                      if(strPeripheral.PowerLEDShowTime >= TIMER_1S)
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 18  

1031   4                      {
1032   5                          ucBeep_Alarm_Phase = 0;
1033   5                          strPeripheral.PowerLEDShowTime = 0;
1034   5                          ucBeep_Alarm_Num = 0;
1035   5                      }
1036   4                      break;
1037   4                  }
1038   3              }
1039   2              else if(strPeripheral.ucRecvTestFlag)
1040   2              {
1041   3                  switch(ucBeep_Alarm_Phase)
1042   3                  {
1043   4                  case 0:
1044   4                      if(strPeripheral.PowerLEDShowTime >= TIMER_400MS)
1045   4                      {
1046   5                          SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 11;
1047   5                          ucBeep_Alarm_Phase = 1;
1048   5                          strPeripheral.PowerLEDShowTime = 0;
1049   5                      }
1050   4                      break;
1051   4                  case 1:
1052   4                      if(strPeripheral.PowerLEDShowTime >= TIMER_20MS)
1053   4                      {
1054   5                          SetPWM1_Out(SpeedKeyTime, SpeedKeyPulse); //·äÃùÆ÷ÏìÒ»Éù
1055   5                          strPeripheral.PowerLEDShowTime = 0;
1056   5                          ucBeep_Alarm_Phase = 2;
1057   5                      }
1058   4                      break;
1059   4                  case 2:
1060   4                      if(strPeripheral.PowerLEDShowTime >= TIMER_20MS)
1061   4                      {
1062   5                          SetPWM1_Out(0, 0); //·äÃùÆ÷ÏìÒ»Éù
1063   5                          strPeripheral.PowerLEDShowTime = 0;
1064   5                          ucBeep_Alarm_Num++;
1065   5                          if(ucBeep_Alarm_Num < 7)
1066   5                              ucBeep_Alarm_Phase = 1;
1067   5                          else
1068   5                              ucBeep_Alarm_Phase = 3;
1069   5                      }
1070   4      
1071   4                      break;
1072   4                  case 3:
1073   4                      if(strPeripheral.PowerLEDShowTime >= TIMER_1S)
1074   4                      {
1075   5                          ucBeep_Alarm_Phase = 0;
1076   5                          strPeripheral.PowerLEDShowTime = 0;
1077   5                          ucBeep_Alarm_Num = 0;
1078   5                      }
1079   4                      break;
1080   4                  default:
1081   4                      ucBeep_Alarm_Phase = 0;
1082   4                      strPeripheral.PowerLEDShowTime = 0;
1083   4                      ucBeep_Alarm_Num = 0;
1084   4                      break;
1085   4                  }
1086   3                  vTestShowLed(strPeripheral.usRecvLedTmp);
1087   3              }
1088   2      #ifdef EnableCancelBackCarAlarm
1089   2              else if((strPeripheral.Input.Bits.SpeedModify) || (strPeripheral.Input.Bits.PowerChange)|| (strPer
             -ipheral.Input.Bits.BackCarAlarmModify))
1090   2              {
1091   3                  if(strPeripheral.PowerLEDShowTime > TIMER_200MS)
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 19  

1092   3                  {
1093   4                      strPeripheral.PowerLEDShowTime = 0;
1094   4                      if(strPeripheral.Input.Bits.BackCarAlarmModify)
1095   4                      {
1096   5                              if(ucEepromBuf[0])
1097   5                              {
1098   6                                  if(strPeripheral.ucPowerLedNum < 6)
1099   6                                  {
1100   7                                      strPeripheral.ucPowerLedNum++;
1101   7                                  }
1102   6                                  else strPeripheral.ucPowerLedNum = 0;                         
1103   6                              }
1104   5                              else
1105   5                              {
1106   6                                  if(strPeripheral.ucPowerLedNum > 0)
1107   6                                  {
1108   7                                      strPeripheral.ucPowerLedNum--;
1109   7                                  }
1110   6                                  else strPeripheral.ucPowerLedNum = 5;
1111   6                              }
1112   5                              ucSpeedGrad = strPeripheral.ucPowerLedNum;
1113   5                              SpeedLedOn(ucSpeedGrad);  //ÏÔÊ¾ËÙ¶È
1114   5                              PowerLedNumOn(strPeripheral.ucPowerLedNum);
1115   5                      }
1116   4                      else
1117   4                      {
1118   5                          if((ucEepromBuf[2] & 0x40) == 0x40)//ï®µç³Ø
1119   5                          {
1120   6                              if(strPeripheral.ucPowerLedNum < 6)
1121   6                              {
1122   7                                  strPeripheral.ucPowerLedNum++;
1123   7                              }
1124   6                              else strPeripheral.ucPowerLedNum = 0;
1125   6                          }
1126   5                          else//Ç¦Ëáµç³Ø
1127   5                          {
1128   6                              if(strPeripheral.ucPowerLedNum > 0)
1129   6                              {
1130   7                                  strPeripheral.ucPowerLedNum--;
1131   7                              }
1132   6                              else strPeripheral.ucPowerLedNum = 5;
1133   6                          }
1134   5                          PowerLedNumOn(strPeripheral.ucPowerLedNum);
1135   5                      }
1136   4                  }
1137   3              }
1138   2      #else         
                      else if((strPeripheral.Input.Bits.SpeedModify) || (strPeripheral.Input.Bits.PowerChange))
                      {
                          if(strPeripheral.PowerLEDShowTime > TIMER_200MS)
                          {
                              strPeripheral.PowerLEDShowTime = 0;
                              if((ucEepromBuf[2] & 0x40) == 0x40)//ï®µç³Ø
                              {
                                  if(strPeripheral.ucPowerLedNum < 6)
                                  {
                                      strPeripheral.ucPowerLedNum++;
                                  }
                                  else strPeripheral.ucPowerLedNum = 0;
                              }
                              else//Ç¦Ëáµç³Ø
                              {
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 20  

                                  if(strPeripheral.ucPowerLedNum > 0)
                                  {
                                      strPeripheral.ucPowerLedNum--;
                                  }
                                  else strPeripheral.ucPowerLedNum = 5;
              
                              }
                              PowerLedNumOn(strPeripheral.ucPowerLedNum);
                          }
                      }
              #endif        
1165   2              else //²»ÔÚ³äµçÖÐ ²¢ÇÒÎÞ¹ÊÕÏ Õý³£ÏÔÊ¾µçÁ¿
1166   2              {
1167   3                  ucBeep_Alarm_Phase = 0;
1168   3                  ucBeep_Alarm_Num = 0;
1169   3                  if(TRUE == strPeripheral.usRecvPowerOFF_Flag)//¹Ø»ú
1170   3                  {
1171   4                      if(GLOBAL_SPEED_GRAD != ucSpeedGrad)
1172   4                      {
1173   5                          EEPROM_WriteByte(SPEED_ADDRESS, ucSpeedGrad);
1174   5                          ucSpeedGrad = GLOBAL_SPEED_GRAD;
1175   5                      }
1176   4                      SPEED_LED_0;   //¹Ø±ÕËÙ¶ÈµÆ
1177   4                      POWER_SHOW_0;  //¹Ø±ÕµçÔ´µÆ
1178   4                      strPeripheral.ucPowerLedShowPhase = 0;
1179   4                      strPeripheral.ucRecvData_Flag = FALSE;
1180   4                      strPeripheral.PowerLEDShowTime = 0;
1181   4                      strPeripheral.ucRecvPowerValue_Flag = 0;
1182   4                  }
1183   3                  else if(strPeripheral.ucRecvPowerValue_Flag)//(strPeripheral.PowerLEDShowTime > TIMER_300MS)
1184   3                  {
1185   4                      PowerLedOn(strPeripheral.uiRecvPowerValue); //ÏÔÊ¾µçÁ¿
1186   4                      SpeedLedOn(ucSpeedGrad);  //ÏÔÊ¾ËÙ¶È
1187   4                  }
1188   3              }
1189   2              /*******·äÃùÆ÷*******/
1190   2      
1191   2              if(Globle_Timer_1MS.Bits.Beep_Alarm)
1192   2              {
1193   3                  Globle_Timer_1MS.Bits.Beep_Alarm = 0;
1194   3                  if ((TRUE == strPeripheral.ucRecvBikeInBack) && (TRUE != strPeripheral.ucRecvOrderInCharge) &&
             - (FALSE == ucBuzzerPressedFlg) && (0 == strPeripheral.ucRecvAlarmNum) )
1195   3                  {
1196   4                      strPeripheral.BackSpeekTime++;
1197   4                  }
1198   3                  if(strPeripheral.Output.Bits.Alarm)
1199   3                  {
1200   4                      strPeripheral.AlarmTime++;
1201   4                  }
1202   3              }
1203   2              if(strPeripheral.BackSpeekTime > TIMER_600MS)
1204   2              {
1205   3                  strPeripheral.BackSpeekTime = 0;
1206   3                  if(ucBackSpeekFlag)
1207   3                  {
1208   4                      SetPWM1_Out(InBackTime, InBackPulse);
1209   4                      ucBackSpeekFlag = FALSE;
1210   4                  }
1211   3                  else
1212   3                  {
1213   4                      SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 12;
1214   4                      ucBackSpeekFlag = TRUE;
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 21  

1215   4                  }
1216   3              }
1217   2              if(strPeripheral.AlarmTime > TIMER_100MS)
1218   2              {
1219   3                  strPeripheral.AlarmTime = 0;
1220   3                  if(FALSE == strPeripheral.Input.Bits.SpeakerKey)SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker 
             -= 13;
1221   3                  strPeripheral.Output.Bits.Alarm = 0;
1222   3              }
1223   2          }//´®¿ÚÍ¨ÐÅºóÖ´ÐÐ
1224   1      }
1225          void vSpeakershutOut(void)
1226          {
1227   1          if(usReadSpeakerPwm() && Globle_Timer_1MS.Bits.CheckIDele)
1228   1          {
1229   2              Globle_Timer_1MS.Bits.CheckIDele = 0;
1230   2              if((0 == strPeripheral.ucRecvBikeInBack) && (0 == ucLess18Power) &&
1231   2                      (0 == strPeripheral.ucRecvAlarmNum) &&  (FALSE == ucBuzzerTstFlg) && (FALSE == ucBuzzerPre
             -ssedFlg) &&
1232   2                      (0 == ucKeyPressFlag) &&  (0 == strPeripheral.ucRecvWrite60Bytes_Flag) && (0x03 == strPeri
             -pheral.usRecvPowerON_Flag) &&
1233   2                      (0 == strPeripheral.SpeakerAndSpeedUpTime) && (0 == strPeripheral.SpeedDownAndUpTime) && (
             -0 == strPeripheral.SpeedDownKeyTime) &&
1234   2                      (0 == strPeripheral.SpeedUpKeyTime) )
1235   2              {
1236   3                  SetPWM1_Out(SpeedKeyTime, 0);//ucDebugSpeaker = 14;
1237   3                  for(ucKeyPressFlag = 0; ucKeyPressFlag < 60; ucKeyPressFlag++)
1238   3                  {
1239   4                      Globle_Timer_1MS.Bits.CheckIDele  = 0;
1240   4                      while(0 == Globle_Timer_1MS.Bits.CheckIDele);
1241   4                  }
1242   3                  vSendBuzzerOrder(0x02);
1243   3                  Globle_Timer_1MS.Bits.CheckIDele = ucKeyPressFlag = 0;
1244   3              }
1245   2          }
1246   1      }
1247          #ifdef BatteryAutoShiBie
1248          void PeripheralHandle(void)
1249          {
1250   1          PeripheralOutputHandle();//µçÁ¿Ö¸Ê¾µÆ¡¢ËÙ¶ÈÖ¸Ê¾µÆ¡¢·äÃùÆ÷¡¢EEPROM
1251   1      
1252   1          if(0x03 == strPeripheral.ucRecvData_Flag)    //´®¿ÚÍ¨ÐÅ¸³Öµ0X03
1253   1          {
1254   2              if(strPeripheral.uiRecvPowerValue)//µçÁ¿²»ÎªÁãÊ±²Å¼ì²â°´¼ü
1255   2              {
1256   3                  PeripheralInputHandle();
1257   3              }
1258   2      
1259   2              ////////////////////
1260   2              //        if(4 == ucSpeedGrad)
1261   2              //        {
1262   2              //          ucTestBeep = 100;
1263   2              //        }
1264   2              //        if(ucTestBeep)
1265   2              //        {
1266   2              //            SetPWM1_Out(SpeedKeyTime, ucTestBeep);
1267   2              //            ucTestBeep = 0;
1268   2              //        }
1269   2              ////////////////////////
1270   2              vSpeakershutOut();
1271   2          }
1272   1      }
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 22  

1273          #endif
1274          
1275          #ifdef OldZuHeAnjian
              void PeripheralHandle(void)
              {
                  PeripheralOutputHandle();//µçÁ¿Ö¸Ê¾µÆ¡¢ËÙ¶ÈÖ¸Ê¾µÆ¡¢·äÃùÆ÷¡¢EEPROM
              
                  if(0x03 == strPeripheral.ucRecvData_Flag)    //´®¿ÚÍ¨ÐÅ¸³Öµ0X03
                  {
                      if(strPeripheral.uiRecvPowerValue)//µçÁ¿²»ÎªÁãÊ±²Å¼ì²â°´¼ü
                      {
                          PeripheralInputHandle();
                      }
                      vSpeakershutOut();
                  }
              }
              #endif
1290          
1291          #ifdef YueYueZuHeAnjian
              void PeripheralHandle(void)
              {
                  PeripheralOutputHandle();//µçÁ¿Ö¸Ê¾µÆ¡¢ËÙ¶ÈÖ¸Ê¾µÆ¡¢·äÃùÆ÷¡¢EEPROM
              
                  if(0x03 == strPeripheral.ucRecvData_Flag)    //´®¿ÚÍ¨ÐÅ¸³Öµ0X03
                  {
                      if(strPeripheral.uiRecvPowerValue)//µçÁ¿²»ÎªÁãÊ±²Å¼ì²â°´¼ü
                      {
                          PeripheralInputHandle();
                      }
                      vSpeakershutOut();
                  }
              }
              #endif
1306          
1307          /************************************************
1308          ;  *    @Function Name       : EEPROM_Byte_Erase
1309          ;  *    @Description         : eeprom×Ö²Á³ýÄ£Ê½³õÊ¼»¯
1310          ;  *    @IN_Parameter        :addar 0-0x3ff W_data Êý¾Ý
1311          ;  *    @Return parameter    :
1312          ;  ***********************************************/
1313          void EEPROM_Byte_Erase(unsigned int addar)
1314          {
1315   1          clr_EA;
1316   1          SET_IAPEN();
1317   1          SET_IAPEN(); //´ò¿ªFALSH IAP¹¦ÄÜ£¬Á¬ÐøÐ´Á½±éÓÐÐ§
1318   1          SET_EPAGEERS();
1319   1          SET_EPAGEERS(); //Ò³²ÁÄ£Ê½
1320   1          IAPKEY = 0x5a;
1321   1          IAPKEY = 0xa5;
1322   1          SET_IAPSTR(); //IAPSTRÎ»ÖÃÒ»£¬Æô¶¯IAP²Ù×÷
1323   1          IAPADH = (addar >> 8) & 0xff;
1324   1          IAPADL = addar & 0xff;
1325   1          IAPDB = 0;
1326   1          IAPADL &= 0xf0;
1327   1          IAPKEY = 0x5a;
1328   1          IAPKEY = 0xa5;
1329   1          SET_IAPTRIG0(); //IAPTRIG0ÖÃÒ»
1330   1          IAPKEY = 0x5a;
1331   1          IAPKEY = 0xa5;
1332   1          SET_IAPTRIG1(); //IAPTRIG1ÖÃÒ»
1333   1          IAPKEY = 0x5a;
1334   1          IAPKEY = 0xa5;
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 23  

1335   1          SET_IAPTRIG2(); //IAPTRIG1ÖÃÒ»
1336   1          while (IAPCR & 0x80);
1337   1      
1338   1      }
1339          /************************************************
1340          ;  *    @Function Name       : EEPROM_Init_Byte_Write
1341          ;  *    @Description         : eeprom×Ö½ÚÐ´
1342          ;  *    @IN_Parameter        : addar 0-0x3ff W_data Êý¾Ý
1343          ;  *    @Return parameter    :
1344          ;  ***********************************************/
1345          void EEPROM_Byte_Write(unsigned int addar, unsigned char W_data)
1346          {
1347   1      
1348   1          SET_IAPEN();
1349   1          SET_IAPEN(); //´ò¿ªFALSH IAP¹¦ÄÜ£¬Á¬ÐøÐ´Á½±éÓÐÐ§
1350   1          SET_EPAGEWR();
1351   1          SET_EPAGEWR(); //Ò³Ð´Ä£Ê½
1352   1          IAPKEY = 0x5a;
1353   1          IAPKEY = 0xa5;
1354   1          SET_IAPSTR(); //IAPSTRÎ»ÖÃÒ»£¬Æô¶¯IAP²Ù×÷
1355   1          IAPADH = (addar >> 8) & 0xff;
1356   1          IAPADL = addar & 0xff;
1357   1          IAPDB = W_data; //W_data
1358   1          IAPADL &= 0xf0;
1359   1          IAPKEY = 0x5a;
1360   1          IAPKEY = 0xa5;
1361   1          SET_IAPTRIG0(); //IAPTRIG0ÖÃÒ»
1362   1          IAPKEY = 0x5a;
1363   1          IAPKEY = 0xa5;
1364   1          SET_IAPTRIG1(); //IAPTRIG1ÖÃÒ»
1365   1          IAPKEY = 0x5a;
1366   1          IAPKEY = 0xa5;
1367   1          SET_IAPTRIG2(); //IAPTRIG1ÖÃÒ»
1368   1          while (IAPCR & 0x80);
1369   1          set_EA;
1370   1      }
1371          /************************************************
1372          ;  *    @Function Name       : EEPROM_Byte_Read
1373          ;  *    @Description         : eeprom×Ö½Ú¶Á
1374          ;  *    @IN_Parameter        : addar 0-0x3ff
1375          ;  *    @Return parameter    : Êý¾Ý
1376          ;  ***********************************************/
1377          uint8_t EEPROM_Byte_Read(unsigned int addr)
1378          {
1379   1          uint8_t R_data;
1380   1          clr_EA;
1381   1          SET_EERD(); //EERDÖÃ1
1382   1          R_data = *(uint8_t __IO code *)addr;
1383   1          CLR_EERD(); //EERDÇå0
1384   1          set_EA;
1385   1          return R_data;
1386   1      
1387   1      }
1388          /************************************************
1389          ;  *    @Function Name       : EEPROM_Read
1390          ;  *    @Description         : EEPROM°´ÕÕ³¤¶È¶ÁÈ¡
1391          ;  *    @IN_Parameter        :
1392          ;  *    @Return parameter    :
1393          ;  ***********************************************/
1394          void EEPROM_Read(unsigned int addr, unsigned char idata *R_data, unsigned int len)
1395          {
1396   1          uint16_t cnt;
C51 COMPILER V9.52.0.0   FUNCTION                                                          07/13/2021 15:24:47 PAGE 24  

1397   1          clr_EA;
1398   1          SET_EERD(); //EERDÖÃ1
1399   1          for (cnt = 0; cnt < len; cnt++)
1400   1          {
1401   2              R_data[cnt] = *(uint8_t __IO code *)addr;
1402   2              addr++;
1403   2          }
1404   1          CLR_EERD(); //EERDÇå0
1405   1          set_EA;
1406   1      }
1407          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3705    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     59      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
